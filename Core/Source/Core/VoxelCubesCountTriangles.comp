#version 430 core

// Compute shader - one thread per cube
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer noiseBuffer {
    float noiseMap[];
};

// Edge array: stores vertex index for each potential edge
layout(std430, binding = 1) buffer CounterBuffer {
    int counter;  
};

uniform int gridWidth; 
uniform int gridHeight;
uniform int gridDepth;
uniform vec3 offset;

bool IsSolid(int x, int y, int z)
{
    int index = x + y * (gridWidth) + z * (gridWidth) * (gridHeight);
    return noiseMap[index] > 0;
}

void main() {
    
    vec3 position = gl_GlobalInvocationID.xyz;

    vec3 paddedNoisePosition = vec3(int(position.x),int(position.y),int(position.z)) + vec3(1,1,1);
    
    if(paddedNoisePosition.x >= gridWidth-2 || paddedNoisePosition.y >= gridHeight-2 || paddedNoisePosition.z >= gridDepth-2) return;
    
    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z))) return;
    
    vec3 base = vec3(int(paddedNoisePosition.x),int(paddedNoisePosition.y),int(paddedNoisePosition.z)) + vec3(offset.x, offset.y, offset.z);
    
    if (!IsSolid(int(paddedNoisePosition.x) + 1, int(paddedNoisePosition.y), int(paddedNoisePosition.z)))
    {
        atomicAdd(counter, 1);
    }
    if (!IsSolid(int(paddedNoisePosition.x) - 1, int(paddedNoisePosition.y), int(paddedNoisePosition.z)))
    {
        atomicAdd(counter, 1);
    }

    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y) + 1, int(paddedNoisePosition.z)))
    {
        atomicAdd(counter, 1);
    }
    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y) - 1, int(paddedNoisePosition.z)))
    {
        atomicAdd(counter, 1);
    }

    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z) + 1))
    {
        atomicAdd(counter, 1);
    }
    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z) - 1))
    {
        atomicAdd(counter, 1);
    }
}