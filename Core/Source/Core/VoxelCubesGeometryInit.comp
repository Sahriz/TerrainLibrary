#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer NoiseBuffer{
	float noiseMap[];
};
layout(std430, binding = 1) buffer VertexBuffer{
	float vertices[];
};
layout(std430, binding = 2) buffer NormalBuffer{
	float normals[];
};
layout(std430, binding = 3) buffer IndexBuffer{
	int indices[];
};

layout(std430, binding = 4) buffer IndexCounterBuffer{
	int indexCounter;
};
layout(std430, binding = 5) buffer VertexCounterBuffer{
    int vertexCounter;
};

vec3[] cornerOffset = { vec3(0.0f,0.0f, 0.0f), vec3(1.0f, 0.0f, 0.0f),
								vec3(1.0f, 0.0f, 1.0f),vec3(0.0f, 0.0f, 1.0f),
								vec3(0.0f, 1.0f, 0.0f), vec3(1.0f, 1.0f, 0.0f),
								vec3(1.0f, 1.0f, 1.0f),  vec3(0.0f, 1.0f, 1.0f)};

uniform int gridWidth; 
uniform int gridHeight;
uniform int gridDepth;
uniform vec3 offset;

bool IsSolid(int x, int y, int z)
{
    if(x >= gridWidth || y >= gridHeight || z >= gridDepth) return false;

    return noiseMap[x + y * (gridWidth+1) + z * (gridWidth+1) * (gridHeight+1)] > 0;
}

void main(){

	vec3 position = gl_GlobalInvocationID.xyz;

    if(position.x >= gridWidth || position.y >= gridHeight, position.z >= gridDepth) return;
    
    if (!IsSolid(int(position.x), int(position.y), int(position.z))) return;
    
    vec3 base = vec3(int(position.x), int(position.y), int(position.z)) + vec3(offset.x, offset.y, offset.z);

	if (!IsSolid(int(position.x) + 1, int(position.y), int(position.z)))
    {
        vec3 v0 = base + cornerOffset[1];
        vec3 v1 = base + cornerOffset[5];
        vec3 v2 = base + cornerOffset[6];
        vec3 v3 = base + cornerOffset[2];

        vec3 normal = vec3(1.f, 0.f, 0.f);
        
        
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(position.x) - 1, int(position.y), int(position.z)))
    {
        vec3 v0 = base + cornerOffset[3];
        vec3 v1 = base + cornerOffset[7];
        vec3 v2 = base + cornerOffset[4];
        vec3 v3 = base + cornerOffset[0];

        vec3 normal = vec3(-1.f, 0.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(position.x), int(position.y) + 1, int(position.z)))
    {
        vec3 v0 = base + cornerOffset[4];
        vec3 v1 = base + cornerOffset[7];
        vec3 v2 = base + cornerOffset[6];
        vec3 v3 = base + cornerOffset[5];

        vec3 normal = vec3(0.f, 1.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(position.x), int(position.y) - 1, int(position.z)))
    {
        vec3 v0 = base + cornerOffset[1];
        vec3 v1 = base + cornerOffset[2];
        vec3 v2 = base + cornerOffset[3];
        vec3 v3 = base + cornerOffset[0];

        vec3 normal = vec3(0.f, -1.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }

    if (!IsSolid(int(position.x), int(position.y), int(position.z) + 1))
    {
        vec3 v0 = base + cornerOffset[2];
        vec3 v1 = base + cornerOffset[6];
        vec3 v2 = base + cornerOffset[7];
        vec3 v3 = base + cornerOffset[3];

        vec3 normal = vec3(0.f, 0.f, 1.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(position.x), int(position.y), int(position.z) - 1))
    {
        vec3 v0 = base + cornerOffset[0];
        vec3 v1 = base + cornerOffset[4];
        vec3 v2 = base + cornerOffset[5];
        vec3 v3 = base + cornerOffset[1];
        
        vec3 normal = vec3(0.f, 0.f, -1.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
}