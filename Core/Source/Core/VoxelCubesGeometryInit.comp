#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer NoiseBuffer{
	int noiseMap[];
};

layout(std430, binding = 1) buffer VertexBuffer{
	float vertices[];
};

layout(std430, binding = 2) buffer NormalBuffer{
	float normals[];
};

layout(std430, binding = 3) buffer IndexBuffer{
	int indices[];
};

layout(std430, binding = 4) buffer IndexCounterBuffer{
	int indexCounter;
};

layout(std430, binding = 5) buffer VertexCounterBuffer{
    int vertexCounter;
};

layout(std430, binding = 6) buffer UVBuffer{
    vec2 uvs[];
};

vec3[] cornerOffset = { vec3(0.0f,0.0f, 0.0f), vec3(1.0f, 0.0f, 0.0f),
								vec3(1.0f, 0.0f, 1.0f),vec3(0.0f, 0.0f, 1.0f),
								vec3(0.0f, 1.0f, 0.0f), vec3(1.0f, 1.0f, 0.0f),
								vec3(1.0f, 1.0f, 1.0f),  vec3(0.0f, 1.0f, 1.0f)};

uniform int gridWidth; 
uniform int gridHeight;
uniform int gridDepth;
uniform vec3 offset;

uniform float columns;
uniform float rows;



bool IsSolid(int x, int y, int z)
{
    int index = x + y * (gridWidth) + z * (gridWidth) * (gridHeight);
    return noiseMap[index] >= 0;
}

void main(){

	vec3 position = gl_GlobalInvocationID.xyz;

    vec3 paddedNoisePosition = vec3(int(position.x),int(position.y),int(position.z)) + vec3(1,1,1);

    if(paddedNoisePosition.x >= gridWidth-1 || paddedNoisePosition.y >= gridHeight-1 || paddedNoisePosition.z >= gridDepth-1) return;
    
    if(!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z))) return;
    
    vec3 base = vec3(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z)) + vec3(offset.x, offset.y, offset.z);
    float tileW = 1.0f / columns;
    float tileH = 1.0f / rows;
    int rowFromBottom = (16 - noiseMap[int(paddedNoisePosition.x) + int(paddedNoisePosition.y) * (gridWidth) + int(paddedNoisePosition.z) * (gridWidth) * (gridHeight)]);
    float epsilon = 0.001f;
    float paddingU = 1.0f/columns/18.0f;
    float paddingV = 1.0f/rows/18.0f;
	if (!IsSolid(int(paddedNoisePosition.x) + 1, int(paddedNoisePosition.y), int(paddedNoisePosition.z)))
    {
        vec3 v0 = base + cornerOffset[1];
        vec3 v1 = base + cornerOffset[5];
        vec3 v2 = base + cornerOffset[6];
        vec3 v3 = base + cornerOffset[2];

        vec3 normal = vec3(1.f, 0.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint Index = baseVertIndex / uint(3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        
    

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;

        float columnIndex = 1.0f;
        
        float u_0 = columnIndex * tileW ;
        float v_0 = rowFromBottom * tileH ;
        float u_1 = u_0 + tileW;
        float v_1 = v_0 + tileH;

        uvs[Index + 0] = vec2(u_0,v_0);
        uvs[Index + 1] = vec2(u_0,v_1);
        uvs[Index + 2] = vec2(u_1,v_1);
        uvs[Index + 3] = vec2(u_1,v_0);
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(paddedNoisePosition.x) - 1, int(paddedNoisePosition.y), int(paddedNoisePosition.z)))
    {
        vec3 v0 = base + cornerOffset[3];
        vec3 v1 = base + cornerOffset[7];
        vec3 v2 = base + cornerOffset[4];
        vec3 v3 = base + cornerOffset[0];

        vec3 normal = vec3(-1.f, 0.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;

        float columnIndex = 1.0f;

        float u_0 = columnIndex * tileW ;
        float v_0 = rowFromBottom * tileH ;
        float u_1 = u_0 + tileW;
        float v_1 = v_0 + tileH;

        uvs[Index + 0] = vec2(u_0,v_0);
        uvs[Index + 1] = vec2(u_0,v_1);
        uvs[Index + 2] = vec2(u_1,v_1);
        uvs[Index + 3] = vec2(u_1,v_0);
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y) + 1, int(paddedNoisePosition.z)))
    {
        vec3 v0 = base + cornerOffset[4];
        vec3 v1 = base + cornerOffset[7];
        vec3 v2 = base + cornerOffset[6];
        vec3 v3 = base + cornerOffset[5];

        vec3 normal = vec3(0.f, 1.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;

        float columnIndex = 0.0f;
        
        float u_0 = columnIndex * tileW ;
        float v_0 = rowFromBottom * tileH ;
        float u_1 = u_0 + tileW;
        float v_1 = v_0 + tileH;

        uvs[Index + 0] = vec2(u_0,v_0);
        uvs[Index + 1] = vec2(u_0,v_1);
        uvs[Index + 2] = vec2(u_1,v_1);
        uvs[Index + 3] = vec2(u_1,v_0);
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y) - 1, int(paddedNoisePosition.z)))
    {
        vec3 v0 = base + cornerOffset[1];
        vec3 v1 = base + cornerOffset[2];
        vec3 v2 = base + cornerOffset[3];
        vec3 v3 = base + cornerOffset[0];

        vec3 normal = vec3(0.f, -1.f, 0.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;

        float columnIndex = 2.0f;

        float u_0 = columnIndex * tileW ;
        float v_0 = rowFromBottom * tileH ;
        float u_1 = u_0 + tileW;
        float v_1 = v_0 + tileH;

        uvs[Index + 0] = vec2(u_0,v_0);
        uvs[Index + 1] = vec2(u_0,v_1);
        uvs[Index + 2] = vec2(u_1,v_1);
        uvs[Index + 3] = vec2(u_1,v_0);
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }

    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z) + 1))
    {
        vec3 v0 = base + cornerOffset[2];
        vec3 v1 = base + cornerOffset[6];
        vec3 v2 = base + cornerOffset[7];
        vec3 v3 = base + cornerOffset[3];

        vec3 normal = vec3(0.f, 0.f, 1.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;

        float columnIndex = 1.0f;

        float u_0 = columnIndex * tileW ;
        float v_0 = rowFromBottom * tileH ;
        float u_1 = u_0 + tileW;
        float v_1 = v_0 + tileH;

        uvs[Index + 0] = vec2(u_0,v_0);
        uvs[Index + 1] = vec2(u_0,v_1);
        uvs[Index + 2] = vec2(u_1,v_1);
        uvs[Index + 3] = vec2(u_1,v_0);
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
    if (!IsSolid(int(paddedNoisePosition.x), int(paddedNoisePosition.y), int(paddedNoisePosition.z) - 1))
    {
        vec3 v0 = base + cornerOffset[0];
        vec3 v1 = base + cornerOffset[4];
        vec3 v2 = base + cornerOffset[5];
        vec3 v3 = base + cornerOffset[1];
        
        vec3 normal = vec3(0.f, 0.f, -1.f);
        
        uint baseVertIndex = atomicAdd(vertexCounter, 4*3);
        uint baseIndex = atomicAdd(indexCounter, 6);
        uint Index = baseVertIndex / uint(3);

        vertices[baseVertIndex + 0] = v0.x;
        vertices[baseVertIndex + 1] = v0.y;
        vertices[baseVertIndex + 2] = v0.z;

        vertices[baseVertIndex + 3] = v1.x;
        vertices[baseVertIndex + 4] = v1.y;
        vertices[baseVertIndex + 5] = v1.z;

        vertices[baseVertIndex + 6] = v2.x;
        vertices[baseVertIndex + 7] = v2.y;
        vertices[baseVertIndex + 8] = v2.z;

        vertices[baseVertIndex + 9] = v3.x;
        vertices[baseVertIndex + 10] = v3.y;
        vertices[baseVertIndex + 11] = v3.z;
        
        normals[baseVertIndex + 0] = normal.x;
        normals[baseVertIndex + 1] = normal.y;
        normals[baseVertIndex + 2] = normal.z;

        normals[baseVertIndex + 3] = normal.x;
        normals[baseVertIndex + 4] = normal.y;
        normals[baseVertIndex + 5] = normal.z;

        normals[baseVertIndex + 6] = normal.x;
        normals[baseVertIndex + 7] = normal.y;
        normals[baseVertIndex + 8] = normal.z;

        normals[baseVertIndex + 9] = normal.x;
        normals[baseVertIndex + 10] = normal.y;
        normals[baseVertIndex + 11] = normal.z;

        float columnIndex = 1.0f;

        float u_0 = columnIndex * tileW ;
        float v_0 = rowFromBottom * tileH ;
        float u_1 = u_0 + tileW;
        float v_1 = v_0 + tileH;

        uvs[Index + 0] = vec2(u_0,v_0);
        uvs[Index + 1] = vec2(u_0,v_1);
        uvs[Index + 2] = vec2(u_1,v_1);
        uvs[Index + 3] = vec2(u_1,v_0);
        
        indices[baseIndex + 0] = int(Index);
        indices[baseIndex + 1] = int(Index + 1);
        indices[baseIndex + 2] = int(Index + 2);
        
        indices[baseIndex + 3] = int(Index);
        indices[baseIndex + 4] = int(Index + 2);
        indices[baseIndex + 5] = int(Index + 3);
    }
}