#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer CounterBuffer{
	int triangleCount;
};
layout(std430, binding = 1) buffer NoiseBuffer{
	float noiseValues[];
};
layout(std430, binding = 2) buffer TriTableBuffer{
    int triTable[];
};

uniform int width;
uniform int height;
uniform int depth;
uniform vec3 offset;
uniform float isoLevel;

vec3 cornerOffsets[] = 
		{
			vec3(0, 0, 0),
			vec3(1, 0, 0),
			vec3(1, 0, 1),
			vec3(0, 0, 1),
			vec3(0, 1, 0),
			vec3(1, 1, 0),
			vec3(1, 1, 1),
			vec3(0, 1, 1),
		};

int edgeTable[] =  {
			0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
				0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
				0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
				0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
				0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
				0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
				0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
				0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
				0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
				0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
				0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
				0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
				0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
				0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
				0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
				0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
				0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
				0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
				0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
				0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
				0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
				0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
				0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
				0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
				0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
				0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
				0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
				0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
				0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
				0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
				0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
				0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0   };



vec3 VertInterp(float iso, vec3 p1, vec3 p2, float v1, float v2)
{
    // Handle edge cases to match Bourke's paper
    if (abs(iso - v1) < 0.00001f)
        return p1;
    if (abs(iso - v2) < 0.00001f)
        return p2;
    if (abs(v1 - v2) < 0.00001f)
        return p1;
    
    

    float mu = (iso - v1) / (v2 - v1);
    return p1 + mu * (p2 - p1);
}

void main(){
	uint xPos = gl_GlobalInvocationID.x;
	uint yPos = gl_GlobalInvocationID.y;
	uint zPos = gl_GlobalInvocationID.z;

	 if (xPos >= uint(width-1) || yPos >= uint(height-1) || zPos >= uint(depth-1))
        return;

	vec3 cubeCorners[8];
    float cubeValues[8];
	for (int i = 0; i < 8; i++)
    {
        vec3 corner = vec3(int(xPos), int(yPos), int(zPos)) + cornerOffsets[i];
        int ix = int(corner.x);
        int iy = int(corner.y);
        int iz = int(corner.z);
        
        ix = clamp(ix, 0, width);
        iy = clamp(iy, 0, height);
        iz = clamp(iz, 0, depth);

        int idx = ix + iy * (width) + iz * (width) * (height);
        cubeCorners[i] = (corner + vec3(offset.x, offset.y, offset.z)); // optionally scale it

        cubeValues[i] = noiseValues[idx];
    }

// 2. Calculate cubeIndex
    int cubeIndex = 0;
    for (int t = 0; t < 8; t++)
    {
        if (cubeValues[t] < isoLevel)
            cubeIndex |= (1 << t);
    }
    
    if (edgeTable[cubeIndex] == 0)
        return;

    // 4. Compute interpolated vertex positions
    vec3 vertList[12];
    if ((edgeTable[cubeIndex] & 1) != 0)
        vertList[0] = VertInterp(isoLevel, cubeCorners[0], cubeCorners[1], cubeValues[0], cubeValues[1]);
    if ((edgeTable[cubeIndex] & 2) != 0)
        vertList[1] = VertInterp(isoLevel, cubeCorners[1], cubeCorners[2], cubeValues[1], cubeValues[2]);
    if ((edgeTable[cubeIndex] & 4) != 0)
        vertList[2] = VertInterp(isoLevel, cubeCorners[2], cubeCorners[3], cubeValues[2], cubeValues[3]);
    if ((edgeTable[cubeIndex] & 8) != 0)
        vertList[3] = VertInterp(isoLevel, cubeCorners[3], cubeCorners[0], cubeValues[3], cubeValues[0]);
    if ((edgeTable[cubeIndex] & 16) != 0)
        vertList[4] = VertInterp(isoLevel, cubeCorners[4], cubeCorners[5], cubeValues[4], cubeValues[5]);
    if ((edgeTable[cubeIndex] & 32) != 0)
        vertList[5] = VertInterp(isoLevel, cubeCorners[5], cubeCorners[6], cubeValues[5], cubeValues[6]);
    if ((edgeTable[cubeIndex] & 64) != 0)
        vertList[6] = VertInterp(isoLevel, cubeCorners[6], cubeCorners[7], cubeValues[6], cubeValues[7]);
    if ((edgeTable[cubeIndex] & 128) != 0)
        vertList[7] = VertInterp(isoLevel, cubeCorners[7], cubeCorners[4], cubeValues[7], cubeValues[4]);
    if ((edgeTable[cubeIndex] & 256) != 0)
        vertList[8] = VertInterp(isoLevel, cubeCorners[0], cubeCorners[4], cubeValues[0], cubeValues[4]);
    if ((edgeTable[cubeIndex] & 512) != 0)
        vertList[9] = VertInterp(isoLevel, cubeCorners[1], cubeCorners[5], cubeValues[1], cubeValues[5]);
    if ((edgeTable[cubeIndex] & 1024) != 0)
        vertList[10] = VertInterp(isoLevel, cubeCorners[2], cubeCorners[6], cubeValues[2], cubeValues[6]);
    if ((edgeTable[cubeIndex] & 2048) != 0)
        vertList[11] = VertInterp(isoLevel, cubeCorners[3], cubeCorners[7], cubeValues[3], cubeValues[7]);

// 5. Emit triangles
    int triIndexBase = cubeIndex * 16;
    for (int q = 0; triTable[triIndexBase + q] != -1; q += 3)
    {
       atomicAdd(triangleCount, 3);
    }
}